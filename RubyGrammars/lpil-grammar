#!/usr/bin/env ruby

require "ruby_grammar_builder"
require_relative "lib/patterns"

lpilG = Grammar.new(
  name: "LPiL",
  scope_name: "source.lpil",
  fileTypes: [ "tex" ],
  version: "0.0.1",
  information_for_contributors: [
    "This json file was auto generated by a much-more-readable ruby file",
    "(e.g. don't edit it directly)",
  ],
)

lpilG[:ambles] = Pattern.new(
  match: Pattern.new(/\%\s+\!LPiL\s+/)
    .oneOf([ /preamble/, /postamble/])
    .then(/\s+=\s+/)
    .then(
      match: /\S+/,
      tag_as: "keyword.control.amble.path"
    ).then(/\s/),
  tag_as: "keyword.control.amble"
)

lpilG[:components] = Pattern.new(
  match: oneOf([ /\\input/, /\\include/ ])
    .then(GPatterns::SimpleArg),
  tag_as: "keyword.control.structure"
)

lpilG[:newcodetype] = Pattern.new(
  match: 
    Pattern.new(/\\newCodeType/)
    .then(GPatterns::SimpleArg)
    .then(GPatterns::SimpleArg),
  tag_as: "keyword.control.newcodetype"
)

lpilG[:lpilcode] = PatternRange.new(
  tag_as: "source.lpilcode",
  start_pattern: Pattern.new(
    match:
      Pattern.new(/\\begin\{lpil\:/)
      .then(
        match: /\w+/,
        tag_as: "keyword.control.source.type",
        reference: "codeType"
      )
      .then(/\}/)
      .then(GPatterns::SimpleArg)
      .then(/\W/),
    tag_as: "keyword.control.source.start"
  ),
  end_pattern: Pattern.new(
    match:
      Pattern.new(/\\end\{lpil\:/)
      .then(
        match: matchResultOf("codeType"),
        tag_as: "keyword.control.source.type"
      ).then(/\}/)
      .then(/\W/),
    tag_as: "keyword.control.source.stop"
  )
)

lpilG[:includeDiagram] = Pattern.new(
  match: Pattern.new(/\\includeLpilDiagram/)
    .then(GPatterns::SimpleArg)
    .then(/\W/),
  tag_as: "keyword.control.includediagram"
)

lpilG[:lpilbuild] = PatternRange.new(
  start_pattern: Pattern.new(
    match: 
    Pattern.new(/\\begin\{lpilBuild\}/)
    .then(GPatterns::SimpleArg)
    .then(GPatterns::SimpleArg)
    .then(/\W/),
    tag_as: "keyword.control.builddescription.start"
  ),
  end_pattern: Pattern.new(
    match: /\\end\{lpilBuild\}\W/,
    tag_as: "keyword.control.builddescription.stop"
  ),
  tag_as: "keyword.control.builddescription",
  tag_content_as: "meta.control.builddescription",
  includes: [
    :lpilrequires,
    :lpilcreates,
    "source.lpil".to_sym
  ]
)

lpilG[:lpilrequires] = Pattern.new(
  match:
    Pattern.new(/\\lpilRequires/)
    .then(GPatterns::SimpleArg)
    .then(GPatterns::SimpleArg)
    .then(/\W/),
  tag_as: "keyword.control.requires"
)

lpilG[:lpilcreates] = Pattern.new(
  match:
    Pattern.new(/\\lpilCreates/)
    .then(GPatterns::SimpleArg)
    .then(GPatterns::SimpleArg)
    .then(/\W/),
  tag_as: "keyword.control.creates"
)

# label/ref/pageref (labels a structure (typically an environment))
lpilG[:label] = Pattern.new(
  match:
    oneOf([/\\label/, /\\ref/, /\\pageref/])
    .then(GPatterns::SimpleArg)
    .then(/\W/),
    tag_as: "keyword.control.label"
  )
  
  # define/index (main definition vs a simple noted use)
  lpilG[:defineIndex] = Pattern.new(
    match: 
    oneOf([/\\define/, /\\index/])
    .then(GPatterns::SimpleArg)
    .maybe(GPatterns::SimpleArg)
    .then(/\W/),
  tag_as: "keyword.control.defineIndex"
)

lpilG[:printIndex] = Pattern.new(
  match: Pattern.new(/\\printindex/).then(/\W/),
  tag_as: "keyword.control.printIndex"
)

# cite (a bib-reference)
lpilG[:cite] = Pattern.new(
  match: 
    Pattern.new(/\\cite/)
    .then(GPatterns::SimpleArg)
    .maybe(GPatterns::SimpleArg)
    .then(/\W/),
  tag_as: "keyword.control.cite"
)

lpilG[:bibliography] = Pattern.new(
  match: 
    Pattern.new(/\\bibliography/)
    .then(GPatterns::SimpleArg)
    .then(/\W/),
  tag_as: "keyword.control.bibliography"
)

# document structure
lpilG[:abstract] = PatternRange.new(
  tag_as: "source.latex.abstract.",
  start_pattern: Pattern.new(
    match: /\\begin\{abstract\}\W/,
    tag_as: "keyword.control.abstract.start"
  ),
  end_pattern: Pattern.new(
    match: /\\end\{abstract\}\W/,
    tag_as: "keyword.control.abstract.stop"
  )
)

lpilG[:sections] = Pattern.new(
  match: Pattern.new(/\\lpil/)
    .oneOf([
      /Title/,
      /Part/,
      /Chapter/,
      /Section/,
      /SubSection/,
      /SubSubSection/,
      /Paragraph/,
      /SubParagraph/
    ])
    .then(GPatterns::SimpleArg)
    .then(GPatterns::SimpleArg)
    .maybe(GPatterns::SimpleArg)
    .then(/\W/),
  tag_as: "keyword.control.sections"
)

lpilG[:matters] = Pattern.new(
  match: oneOf([
    /\\frontmatter/,
    /\\maketitle/,
    /\\mainmatter/,
    /\\appendix/,
    /\\backmatter/
  ]),
  tag_as: "keyword.control.matter"
)

# consider glossaries later....

lpilG[:$initial_context] = [
  :ambles,
  :components,
  :newcodetype,
  :lpilcode,
  :includeDiagram,
  :lpilbuild,
  :lpilRequires,
  :lpilCreates,
  :label,
  :defineIndex,
  :printIndex,
  :cite,
  :bibliography,
  :abstract,
  :sections,
  :matters
]

lpilG.save_to(
    syntax_name: "lpil",
    syntax_dir: "../src/syntaxes",
    tag_dir: "../src/syntaxes",
)
